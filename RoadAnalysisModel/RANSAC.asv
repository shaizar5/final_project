function T = RANSAC(leftPoints, rightPoints, func, n, numOfIteration, threshDist, inlierRatio,  K)
T = zeros(numOfIteration,1);
sizeLeft = size(leftPoints);
sizeRight = size(rightPoints);
if (sizeLeft(1) ~= sizeRight(1) || sizeLeft(2) ~= sizeRight(2))
    'input not have same size'
    return
end

error = zeros(1,numOfIteration);
totalNumOfPoints = size(leftPoints,2);
bestInNum=0;        % Best fitting H with largest number of inliers
bestH = zeros(3,3); 
for i=1:numOfIteration
    % randomly choosing n points
    index = randperm(sizeLeft(2),n);
    if (length(unique(index)) ~= length(index))
        ' bad rand function '
        return
    end
    
    % maybe inliers indices
    currLeft  = leftPoints(:,index);
    currRight = rightPoints(:,index);
    H = Utilities.computeHdirectly(currLeft, currRight);
    
    res = H*[currLeft;ones(1,size(currLeft,2))];
    res = Utilities.divideMatrixByLastRow(res);
    res = res-[currRight;ones(1,size(currRight,2))];
    error = diag(res'*res);
    
    % if point fits with an error smaller than t
    inlierIdx = find(error<=threshDist);
    inlierNum = length(inlierIdx);
    
    if inlierNum>=round(inlierRatio*totalNumOfPoints) && inlierNum>bestInNum
         bestInNum = inlierNum;
         parameter1 = (sample(2,2)-sample(2,1))/(sample(1,2)-sample(1,1));
         parameter2 = sample(2,1)-parameter1*sample(1,1);
         bestParameter1=parameter1; bestParameter2=parameter2;
    end
    
    %res = (H*[currLeft(:,1);ones(1,1)]);
    %res = res./res(3);
    %error(i) = norm(res-[currRight(:,1);ones(1,1)]);
end

%figure(4) ; clf
%axis([1 numOfIteration min(error) max(error)])
%plot ([1:numOfIteration], error, '*-')
end

